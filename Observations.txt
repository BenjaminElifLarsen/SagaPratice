If a specification class contain multiple specification for different data types, the composite extensions requires giving the generic type.
	Not sure, yet, why they are unable to recognise the correct generic version (IsSatisfiedBy) that they should run.
	After all, both sides use the same generic type.
However, since it is possible to compsite the specifications it will allow for some more 'complex' error types, e.g. age above one threshold and below another one and if this fail can cast to a specific error.

An interesting difference between this project and the api backend project. In the api backend the dependency injection did not work if it tried to to create instance of an internal class/interface. They had to be public. 
	Yet, here the same approach is working while the interfaces and classes are internal for some reason. Both solutions use the {domain}ApiServices to help lower the amount of code in Program in the api project.
	The only difference between the two solutions, that could causse this, is the api backend is C Sharp Dotnet 6, while the projects in this solution is using the preview for Dotnet 7.
	From some testing, it needs everything in {domain}Service's ctor to be public, the implementations do not need to be public. The reason {domain}Service is that it is called from outside the project its belong too.
	Domain models also need to be public.
	Seems like the DI is less restrictive than what was first assumed. Expected everything in {domain}ApiServices had to be public too, since it was rquired in the backend.

DateOnly json converter does not work, it seems like, when reading and so different methods have been changed back to DateTime, while trying to fix the json converter.





