When figured out how to best do Saga, make generic version or similar and add to Common project and then push the Common project.

since dealing with events for the saga, maybe look into event sourcing at the same time.

consider based your solution on the Domain Events section from https://vaadin.com/blog/ddd-part-2-tactical-domain-driven-design#_guideline_2_refer_to_other_aggregates_by_id
but code to work with the idea of no service can run all the time
also look at Domain Services


when updating, data should be validated before updating the entities and the entities should validate the data themsevles too and return an interger if data is invalid

The person domain should use the other folder structure than the vehicle domain

https://learn.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/domain-events-design-implementation

rename everything that use 'People' in the Vehicle domain to 'Operator'

Consider how to best use ISpecification regarding entity update. If having e.g. a ISpecification<int>, the model can validate before changing value.
	But if using e.g. ISpecification<Person> then it is locked to the model and ensure ISpecification cannot be used with 'any random' value, but it require updating the value first and then validate. This could put the entity in an invalid status.
	Could recover to the pre-updated value by saving it as a temp in the update method, but not the prettist solution.
	All cases return an int, 0 is valid else an enum int


throw in jwt
two users, one with permission for everything, the other only for some aggregate roots / domains / commands / queries.
set up hasher and salter in security project. Project should have an user model (not all people are users), with id, password (hashed and salted) and username/email.

split up some classes/interfaces to better follow the single responsibility principle.


vehicle event sourcing: Could event source when the vehicle was in use and stopped be in use (operator id, time, bool started, distance moved)

Consider how events with data can best be stored in a context, like a mssql database, given each event got their own Data type.
Could store them as a json string.

consider moving the repos in Vehicle.DL into the IPL 

have a command bus (kind of like the event bus) that takes in commands and transmit them to the command handlers
	the handlers, when done with the command, remove it from the command bus. 
rename the cqrs folder in AL with the command handler and contract to Handlers. Let it be the place for both command handlers and event handlers

figure out what layer would be best for the busses.
	parts:
		event bus
		event handler
		command bus
		command handler
	communication:
		the event handler would communicate with the command bus.
		command bus would communicate with the command handler.
		command handler can create events that are stored in the domain models
		the unit of work publishes, via the event bus, the events.
		the events should be handled by the event handler. 
	dependencies:
		event bus got no dependencies
		event handler needs to talk to the command bus
		the command bus got no dependencies
		the command handler does not talk with any of those parts as events are processed in unit of work
			unit of work needs to talk with the event bus
	possible problem:
		event bus depends on event handler which depends on command bus which depends on command handler which depends on unit of work which depends on event bus which...
		wait, does the busses really depend on the handlers? The handlers need to registrate themselves in the busses, but the busses themselves should have no knowledge of the handler contracts. The busses just want Action<T>s where T : IDomainEvent/ICommand
		ensure you are correct and update dependencies as busses have no dependencies. 
	considerations:
		fact: communication to the layer below is permitted, but not the layer above.
		The busses needs to talk with the handlers. At least the command handler depends on DL and IPL, because of the DL dependency it cannot be placed there.
		Thus the handlers are either in the AL or IPL. Since they have nothing to do with the context or persisting of data, IPL does not make sense.
		Thus the handlers are placed in AL.
		The busses depends on the handlers and are thus also stored in the AL. Wrong, they do not depend on the handlers, the handlers depend on them, and can thus be placed in the DL.
		(The AL is considered a layer above IPL.)
Need to figuere out how to registrate event and commands in the busses. Done via the {Domain}Registry
Remember that the controllers also need to talk with the command busses, but this is not important. Done by applying the command bus and unit of work as parameters to the services.

a command:
	can have many senders, but only one receiver
an event:
	has one sender (the publisher), but zero or many receivers

move operator queries over to their service.


events to do
	licenseType does not get updated when adding a vehicle information
	vehicle information does not get updated when adding a vehicle.


License Type need to deal with CanBeIssedFrom, update specifications, ctor, factory, and error(handling)


have something similar to the middleware to empty the registry




